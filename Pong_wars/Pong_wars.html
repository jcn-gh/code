<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Pong wars</title>
    <link rel="stylesheet" href="Pong_wars.css">
    <meta name="description" content="Pong wars.">
    <meta name="keywords" content="web development, CSS, HTML, JS">
    <meta name="author" content="JCN">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="author" content="Koen van Gilst">
    <meta name="description" content="Pong wars | Koen van Gilst">
    <meta name="keywords" content="web development, CSS, SCSS, HTML, Git, GitHub">
    <meta name="robots" content="noindex">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">
    <link href="https://fonts.googleapis.com/css2?family=Roboto&display=swap" rel="stylesheet">
    <link rel="icon" type="image/png" href="favicon.png"> -->
    <!-- <script src="Pong_wars.js"></script> -->
</head>

<body>
    <div class="container">
        <canvas class="pongCanvas" width="800" height="800"></canvas>
        <div class="score"></div>
    </div>

    <!-- <script>
        // Source palette: https://twitter.com/AlexCristache/status/1738610343499157872
        const colorPalette = {
            ArcticPowder: "#F1F6F4",
            MysticMint: "darkgreen",
            Forsythia: "#FFC801",
            DeepSaffron: "#FF9932",
            Nocturnal: "darkblue",
            OceanicNoir: "#172B36",
        };

        // Idea for Pong wars: https://twitter.com/nicolasdnl/status/1749715070928433161

        const canvas = document.querySelector(".pongCanvas");
        const ctx = canvas.getContext("2d");
        const scoreElement = document.querySelector(".score");

        const DAY_COLOR = colorPalette.MysticMint;
        const DAY_BALL_COLOR = colorPalette.Nocturnal;

        const NIGHT_COLOR = colorPalette.Nocturnal;
        const NIGHT_BALL_COLOR = colorPalette.MysticMint;

        const SQUARE_SIZE = 25;

        const numSquaresX = canvas.width / SQUARE_SIZE;
        const numSquaresY = canvas.height / SQUARE_SIZE;

        const squares = new Array(numSquaresX).fill().map(() => new Array(numSquaresY));

        function updateScoreElement() {
            const scores = squares.flat().reduce((scores, square) => {
                scores[square === DAY_COLOR ? 'day' : 'night']++;
                return scores;
            }, {
                day: 0,
                night: 0
            });

            scoreElement.textContent = `day ${scores.day} | night ${scores.night}`;
        }

        for (let i = 0; i < numSquaresX; i++) {
            squares[i] = [];
            for (let j = 0; j < numSquaresY; j++) {
                squares[i][j] = i < numSquaresX / 2 ? DAY_COLOR : NIGHT_COLOR;
            }
        }

        let x1 = canvas.width / 4;
        let y1 = canvas.height / 2;
        let dx1 = 12.5;
        let dy1 = -12.5;

        let x2 = (canvas.width / 4) * 3;
        let y2 = canvas.height / 2;
        let dx2 = -12.5;
        let dy2 = 12.5;

        let iteration = 0;

        function drawBall(x, y, color) {
            ctx.beginPath();
            ctx.arc(x, y, SQUARE_SIZE / 2, 0, Math.PI * 2, false);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.closePath();
        }

        function drawSquares() {
            for (let i = 0; i < numSquaresX; i++) {
                for (let j = 0; j < numSquaresY; j++) {
                    ctx.fillStyle = squares[i][j];
                    ctx.fillRect(
                        i * SQUARE_SIZE,
                        j * SQUARE_SIZE,
                        SQUARE_SIZE,
                        SQUARE_SIZE
                    );
                }
            }
        }

        function randomNum(min, max) {
            return Math.random() * (max - min) + min;
        }

        function updateSquareAndBounce(x, y, dx, dy, color) {
            let updatedDx = dx;
            let updatedDy = dy;

            // Check multiple points around the ball's circumference
            for (let angle = 0; angle < Math.PI * 2; angle += Math.PI / 4) {
                let checkX = x + Math.cos(angle) * (SQUARE_SIZE / 2);
                let checkY = y + Math.sin(angle) * (SQUARE_SIZE / 2);

                let i = Math.floor(checkX / SQUARE_SIZE);
                let j = Math.floor(checkY / SQUARE_SIZE);

                if (i >= 0 && i < numSquaresX && j >= 0 && j < numSquaresY) {
                    if (squares[i][j] !== color) {
                        squares[i][j] = color;

                        // Determine bounce direction based on the angle
                        if (Math.abs(Math.cos(angle)) > Math.abs(Math.sin(angle))) {
                            updatedDx = -updatedDx;
                        } else {
                            updatedDy = -updatedDy;
                        }

                        // Add some randomness to the bounce to prevent the balls from getting stuck in a loop
                        updatedDx += randomNum(-0.01, 0.01);
                        updatedDy += randomNum(-0.01, 0.01);
                    }
                }
            }

            return {
                dx: updatedDx,
                dy: updatedDy
            };
        }

        function updateScoreElement() {
            let dayScore = 0;
            let nightScore = 0;
            for (let i = 0; i < numSquaresX; i++) {
                for (let j = 0; j < numSquaresY; j++) {
                    if (squares[i][j] === DAY_COLOR) {
                        dayScore++;
                    } else if (squares[i][j] === NIGHT_COLOR) {
                        nightScore++;
                    }
                }
            }

            scoreElement.textContent = `day ${dayScore} | night ${nightScore}`;
        }

        function checkBoundaryCollision(x, y, dx, dy) {
            if (x + dx > canvas.width - SQUARE_SIZE / 2 || x + dx < SQUARE_SIZE / 2) {
                dx = -dx;
            }
            if (
                y + dy > canvas.height - SQUARE_SIZE / 2 ||
                y + dy < SQUARE_SIZE / 2
            ) {
                dy = -dy;
            }

            return {
                dx: dx,
                dy: dy
            };
        }

        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            drawSquares();

            drawBall(x1, y1, DAY_BALL_COLOR);
            let bounce1 = updateSquareAndBounce(x1, y1, dx1, dy1, DAY_COLOR);
            dx1 = bounce1.dx;
            dy1 = bounce1.dy;

            drawBall(x2, y2, NIGHT_BALL_COLOR);
            let bounce2 = updateSquareAndBounce(x2, y2, dx2, dy2, NIGHT_COLOR);
            dx2 = bounce2.dx;
            dy2 = bounce2.dy;

            let boundary1 = checkBoundaryCollision(x1, y1, dx1, dy1);
            dx1 = boundary1.dx;
            dy1 = boundary1.dy;

            let boundary2 = checkBoundaryCollision(x2, y2, dx2, dy2);
            dx2 = boundary2.dx;
            dy2 = boundary2.dy;

            x1 += dx1;
            y1 += dy1;
            x2 += dx2;
            y2 += dy2;

            iteration++;
            if (iteration % 1000 === 0) console.log("iteration", iteration);

            updateScoreElement();

            requestAnimationFrame(draw);
        }

        requestAnimationFrame(draw);
    </script> -->
    <script src="Pong_wars.js"></script>
</body>

</html>