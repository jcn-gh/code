<!DOCTYPE html>
<html lang="es" data-theme="dark">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Checkpoint 18</title>
    <link rel="icon" href="./img/lauburu.png" type="image/x-icon">
    <link rel="stylesheet" href="./css/Checkpoint_18.css">
</head>

<body>
    <main>
        <article>
            <h1 class="typewriter difuminado">Checkpoint 18</h1>
            <p class="center difuminado"><b>Nota</b>: <i>pulsa en la pregunta para ver la respuesta</i><br>
                o sobre una imagen para ampliarla (o devolverla a su tamaño original).
            </p>
            <img class="center" loading="lazy" decoding="async" src="https://www.ecured.cu/images/thumb/a/a6/React-logo.png/1200px-React-logo.png" alt="Cabecera">
            <h2 class="typedelete">¡Disfruta! ☕, Preguntas</h2>
            <ul>
                <li>
                    <h3 tabindex="-1">¿Qué es una función de desplazamiento o <em lang="en">scroll</em> infinito?</h3>
                    <div class="contenido">
                        <img class="center" loading="lazy" decoding="async" src="https://1.bp.blogspot.com/-OwWq6pONWiQ/UZpP8ZcsJ5I/AAAAAAAACyU/WEPm9YneYbg/s1600/scroll+infinito+en+blogger.jpg" alt="Desplazamiento infinito.">
                        <p>Una función de desplazamiento o <em lang="en">scroll</em> infinito (<em lang="en">infinite scrolling</em> o <em lang="en">endless scrolling</em>) es un patrón de navegación en línea que se caracteriza por la capacidad del usuario para seguir navegando hacia abajo/adelante indefinidamente a través de una lista o contenido <em>sin límites</em>.</p>
                        <p>En otras palabras, cuando un sitio web o aplicación utiliza el desplazamiento infinito, el contenido se carga automáticamente mientras el usuario se desplaza hacia abajo, sin requerir un botón “Siguiente” o “Más” para cargar más información. Esto crea la ilusión de que el contenido es ilimitado y puede ser explorado <em>por completo</em>.</p>
                        <p>El desplazamiento infinito se utiliza comúnmente en aplicaciones como:</p>
                        <ul>
                            <li><em>Blogs</em> o sitios web con contenido relacionado</li>
                            <li>Noticias o redes sociales (por ejemplo, Twitter, Facebook)</li>
                            <li>Listas de productos (por ejemplo, Amazon)</li>
                            <li>Juegos en línea que requieren una cantidad significativa de contenido para jugar</li>
                        </ul>
                        <p>Los beneficios del desplazamiento infinito incluyen:</p>
                        <ul>
                            <li>Facilita el descubrimiento de nuevo contenido: al presentar más información relacionada con lo que se está viendo.</li>
                            <li>Incrementa la interacción: al mantener a los usuarios interesados y activos durante más tiempo.</li>
                            <li>Mejora la experiencia del usuario: al permitirle explorar el contenido sin obstáculos.
                            </li>
                        </ul>
                        <img class="center" loading="lazy" decoding="async" src="https://blog.rocketseat.com.br/content/images/size/w1000/2018/12/scroll-infinito-no-react-native.png" alt="Desplazamiento infinito.">
                        <p>También hay situaciones en las que no es lo mejor o incluso puede ser perjudicial para la experiencia del usuario. De hecho, el desplazamiento infinito debe utilizarse con cuidado y considerar los siguientes factores:</p>
                        <ul>
                            <li>Si tienes un pequeño número de artículos, productos o información relacionada, el desplazamiento infinito puede ser engañoso y llevar a la frustración del usuario.</li>
                            <li>Si estás cargando contenido no relevante o desactualizado, el desplazamiento infinito puede ser una forma de perder la atención del usuario y hacer que se sienta
                                <em>molesto</em>.
                            </li>
                            <li>Si el contenido está muy disperso o no está bien organizado, el desplazamiento infinito puede hacer difícil encontrar la información que se está buscando.</li>
                            <li>Si el contenido se carga muy lentamente o con mucho retraso, el desplazamiento infinito puede ser una forma de agobiar a los usuarios y hacer que se sientan frustrados.</li>
                            <li>Si la navegación es compleja o requiere una gran cantidad de clicks para llegar al contenido deseado, el desplazamiento infinito no es lo mejor.</li>
                            <li>Si no hay un final lógico para el contenido (por ejemplo, un <em lang="en">blog</em> que nunca termina), el desplazamiento infinito puede crear confusión y abrumar al usuario.
                            </li>
                            <li>Si tienes demasiado contenido y no hay un sistema efectivo para organizarlo o hacer que sea fácilmente accesible, el desplazamiento infinito puede ser una forma de
                                <em>incomodar</em> al usuario.
                            </li>
                            <li>Si el contenido no está satisfaciendo las necesidades del usuario (por ejemplo, si está
                                buscando una información y no la encuentra), el desplazamiento infinito no es lo mejor.</li>
                        </ul>
                        <p>Si no se cumplen estos requisitos, es más que probable que el desplazamiento infinito no sea la mejor elección para tu aplicación o sitio web.</p>
                        <img class="center" loading="lazy" decoding="async" src="https://wanaleads.com/wp-content/uploads/2020/02/200112-elegir-scroll-o-paginacion.jpg" alt="Paginación tradicional vs. desplazamiento infinito.">
                        <p>En resumen, el desplazamiento infinito es una forma de navegación que puede ser útil para mantener al usuario interesado y activo, pero también debe ser utilizado con cuidado y considerar las necesidades específicas del contenido y la <em>audiencia</em>.</p>

                        <h4>¿Quieres más?</h4>
                        <p>
                            <a tabindex="0" href="https://www.esdesignbarcelona.com/actualidad/diseno/scroll-infinito" target="_blank" rel="noreferrer noopener">Lee</a> o mira este <a tabindex="0" href="https://www.youtube.com/watch?v=m5yS-RsKGTw" target="_blank" rel="noreferrer noopener">video</a>.
                        </p>
                    </div>
                </li>
                <li>
                    <h3 tabindex="-1">¿Qué es un modal?</h3>
                    <div class="contenido">
                        <img class="center" loading="lazy" decoding="async" src="https://i.ytimg.com/vi/c3MbFWr-NT4/maxresdefault.jpg" alt="Ventana modal.">
                        <p>Un modal (también conocido como <em lang="en">overlay, popup</em> o <em lang="en">dialogue</em>) es una ventana emergente que se superpone sobre el contenido principal de una página web o aplicación, y que se utiliza para mostrar información adicional o solicitar la acción del usuario.</p>
                        <img class="center" loading="lazy" decoding="async" src="https://i.pinimg.com/originals/71/29/31/712931ad368379e11a0136d69ecdfc74.gif" alt="Funcionamiento de ventana modal.">
                        <p>Los modales suelen tener las siguientes características:</p>
                        <ul>
                            <li>Superposición: se superpone sobre el contenido principal, cubriendo parte o toda la pantalla.</li>
                            <li>Emergencia: emerge cuando el usuario hace clic en un botón, un enlace o realiza una acción específica.</li>
                            <li>No-negociable: no puede ser cerrado con el ratón o el teclado, excepto si se ha configurado para que sea posible (como por ejemplo, mediante un botón “Cerrar” visible).
                            </li>
                            <li>Foco: suele tener su propio foco de atención, como título, texto y elementos de interfaz.</li>
                        </ul>
                        <img class="center" loading="lazy" decoding="async" src="https://i.sstatic.net/KIQmc.png" alt="Ejemplo de ventana modal.">
                        <p>Los modales pueden ser utilizados para:</p>
                        <ul>
                            <li>Mostrar información adicional: puede mostrar detalles sobre un elemento, como una descripción o una lista de características.</li>
                            <li>Solicitar la acción del usuario: puede pedirle al usuario que tome una decisión, como confirmar una acción o aceptar los términos y condiciones.</li>
                            <li>Realizar una tarea específica: puede ser utilizado para realizar una tarea específica,
                                como enviar un correo electrónico o hacer una pregunta.</li>
                        </ul>
                        <img class="center" loading="lazy" decoding="async" src="https://image.freepik.com/vector-gratis/interfaz-correo-electronico-plantilla-ventana-correo-marco-mensaje-internet-correo-electronico-blanco-ilustracion-moderna_172533-601.jpg" alt="Ventana modal de correo electrónico.">
                        <p>Los modales pueden ser diseñados de manera diferente dependiendo del contexto y el propósito,
                            pero generalmente tienen la siguiente estructura:</p>
                        <ul>
                            <li>El título, que describe su propósito.</li>
                            <li>El contenido principal, como texto, imágenes o elementos de interfaz.</li>
                            <li>Los botones o acciones disponibles dentro del modal, que permiten al usuario tomar una decisión o realizar una tarea.</li>
                        </ul>
                        <img class="center" loading="lazy" decoding="async" src="https://codea.app/img/fotos/diseno-de-ventana-modal-css113.jpeg" alt="Partes de la ventana modal.">
                        <p>Aunque las vetanas modales pueden ser beneficiosas en algunas situaciones, hay momentos en los que no es lo mejor o incluso puede ser perjudicial para la experiencia del usuario. Aquí
                            tienes algunos casos en los que debes considerar con cuidado o evitar el uso de ventanas modales:</p>
                        <ul>
                            <li>Si solo tienes una pequeña cantidad de información adicional que quieres mostrar
                                ¿realmente es necesario?</li>
                            <li>Si hay demasiadas ventanas modales en la aplicación o sitio web, el usuario puede sentir que están siendo bombardeado.</li>
                            <li>Si el contenido dentro del modal no tiene un fin lógico o no es relevante para la tarea que el usuario está realizando ¿no es inútil?</li>
                            <li>Si el contenido principal es importante y debe estar en primer plano, la ventana modal puede distraer al usuario y hacer que no vea el contenido principal.</li>
                            <li>Si el usuario no está listo para recibir información adicional o no tiene tiempo para procesarla ¿acaso no es una distracción innecesaria?</li>
                            <li>Si es difícil de cerrar, o no se puede cerrar con facilidad, el usuario puede sentirse frustrado y abandonar la aplicación o sitio web.</li>
                            <li>Si no hay un sistema efectivo para organizar la información adicional, el usuario puede sentirse, cuando menos, confundido.</li>
                            <li>Si hay demasiada información adicional, el usuario puede sentirse avasallado.</li>
                            <li>Si no hay un método efectivo para solicitar la acción del usuario, puede sentir confusión porque no tiene opciones claras.</li>
                        </ul>
                        <p>Es importante considerar las circunstancias en las que se decide utilizar una ventana modal y asegurarse de que es beneficioso para la experiencia del usuario.</p>
                        <img class="center" loading="lazy" decoding="async" src="https://blog.ida.cl/wp-content/uploads/sites/5/2017/05/Modal.jpg" alt="Ejemplo de ventana modal.">
                        <p>En resumen, un modal es una ventana emergente que se utiliza para mostrar información adicional o solicitar la acción del usuario, y que puede ser diseñado de manera diferente dependiendo del contexto y el propósito.</p>

                        <p>¡¿No te ha quedado claro?! En este
                            <a tabindex="0" href="https://blog.ida.cl/diseno/ldiferencia-modal-pop-up-pop-over-light-box/" target="_blank" rel="noreferrer noopener">artículo</a> y en este <a tabindex="0" href="https://www.youtube.com/watch?v=5c8NLiKW5aI" target="_blank" rel="noreferrer noopener">video</a> te lo pueden aclarar… o no.
                        </p>
                    </div>
                </li>
                <li>
                    <h3 tabindex="-1">¿Cuál es la diferencia entre estado local y estado global en React?</h3>
                    <div class="contenido">
                        <img class="center" loading="lazy" decoding="async" src="https://i.ytimg.com/vi/35lXWvCuM8o/maxresdefault.jpg" alt="Métodos API.">
                        <p>En React, el estado hace referencia a los datos que cambian con el tiempo en la aplicación.
                            Hay dos tipos de estados: el estado local (<span class="keyword">this.state</span>) y el estado global (<span class="keyword">context</span> o <span class="keyword">Redux state</span>).</p>
                        <h4>Estado Local (<span class="keyword">this.state</span>)</h4>
                        <p>El estado local es el estado específico de una instancia de un componente React. Cada componente tiene su propio estado local, que se inicializa con los valores proporcionados en el constructor del componente.</p>
                        <p>Es, quizás, el tipo de estado más fácil de administrar en React, considerando que hay muchas herramientas integradas en la biblioteca central de React para administrarlo.</p>
                        <p>En React, el estado local se gestiona frecuentemente mediante el gancho <span class="keyword">useState</span>.</p>
                        <p>Por ejemplo, el estado local sería necesario para mostrar u ocultar un componente modal o para realizar un seguimiento de los valores de un componente de formulario, como el envío de formulario, cuando el formulario está deshabilitado y los valores de las entradas de un formulario.</p>
                        <p>Ejemplo:</p>
                        <div id="editor00"></div>
                        <p>En este ejemplo, el estado local <span class="keyword">count</span> es específico para cada instancia de la clase <span class="keyword">Counter</span>.</p>
                        <h4>Estado Global (<span class="keyword">context</span> o <span class="keyword">Redux state</span>)</h4>
                        <p>El estado global es el que está disponible en todo el árbol de componentes React. Puede ser compartido entre varios componentes y puede ser actualizado desde cualquier lugar de la aplicación.</p>
                        <p>Es necesario cuando queremos obtener y actualizar datos en cualquier lugar de nuestra aplicación, o, al menos, en varios componentes.</p>
                        <p>Las cosas se ponen un poco más complicadas cuando queremos gestionar el estado en varios componentes.</p>
                        <p>Muchos desarrolladores se inclinan por utilizar funciones integradas de React, como la API Context, para administrar su estado, pero solo es útil para leerlo, no para actualizarlo. Es por ello que es preferible usar una biblioteca de terceros probada como Zustand, Jotai,
                            Recoil y Redux (asegúrate de usar Redux Toolkit).</p>
                        <img class="center" loading="lazy" decoding="async" src="https://i.ytimg.com/vi/BaEWIbxZKco/maxresdefault.jpg" alt="Zustand vs Redux vs Jotai vs Recoil.">
                        <p>Un ejemplo común de estado global es el estado de usuario autenticado. Si un usuario inicia sesión en nuestra aplicación, es necesario obtener y cambiar sus datos en toda nuestra aplicación.</p>
                        <p>Ejemplo con Context API:</p>
                        <div id="editor01"></div>
                        <p>En este ejemplo, el estado global <span class="keyword">count</span> está disponible en todo el árbol de componentes y puede ser actualizado desde cualquier lugar.</p>
                        <p>Ejemplo con Redux:</p>
                        <div id="editor02"></div>
                        <p>En este ejemplo, el estado global <span class="keyword">count</span> está disponible en todo el árbol de componentes y puede ser actualizado desde cualquier lugar mediante la acción
                            <span class="keyword">INCREMENT_COUNT</span>.
                        </p>
                        <p>El mismo ejemplo usando Zustand:</p>
                        <div id="editor03"></div>
                        <p>En esta versión, <span class="keyword">useStore</span> se utiliza para gestionar el estado
                            <span class="keyword">count</span> y la acción <span class="keyword">incrementCount</span>,
                            proporcionando una forma más simple y concisa de gestionar el estado en los componentes React.
                        </p>
                        <img class="center" loading="lazy" decoding="async" src="https://www.bacancytechnology.com/blog/wp-content/uploads/2023/02/Approaches-to-State-Management-in-React.webp" alt="Diferentes formas de manejar el estado en React.">
                        <p>En resumen, el estado local es específico para un componente individual, mientras que el estado global es compartido entre varios componentes y puede ser actualizado desde cualquier lugar.</p>

                        <p>Puedes ampliar perspectivas leyendo este <a tabindex="0" href="https://www.freecodecamp.org/news/what-every-react-developer-should-know-about-state/" target="_blank" rel="noreferrer noopener">artículo</a> o <a tabindex="0" href="https://www.freecodecamp.org/news/how-to-manage-state-in-your-react-apps/" target="_blank" rel="noreferrer noopener">este otro</a>, además de recurrir a la <a tabindex="0" href="https://es.react.dev/learn/managing-state" target="_blank" rel="noreferrer noopener">fuente</a>. También viendo este <a tabindex="0" href="https://www.youtube.com/watch?v=alzVosjIb28" target="_blank" rel="noreferrer noopener">video</a> o este <a tabindex="0" href="https://www.youtube.com/watch?v=Te-gxJrdMdY" target="_blank" rel="noreferrer noopener">otro</a>.</p>
                    </div>
                </li>
                <li>
                    <h3 tabindex="-1">¿Qué es React Router?</h3>
                    <div class="contenido">
                        <img class="center" loading="lazy" decoding="async" src="https://alto-palo.com/wp-content/uploads/2021/03/Introduction-to-React-Router-and-Its-Routing-Installation-1024x576.png" alt="Cabecera PUT vs PATCH.">
                        <h4>¿Qué es React Router?</h4>
                        <p>React Router es una popular librería JavaScript utilizada para el enrutamiento del lado del cliente en aplicaciones React. Permite gestionar la URL del navegador y actualizar la interfaz de usuario. En consecuencia, la creación de una aplicación de una sola página (SPA)
                            que se puede navegar a través de URL.</p>
                        <h4>¿Qué hace?</h4>
                        <p>React Router proporciona varias características clave:</p>
                        <ul>
                            <li>Permite crear rutas para la aplicación y asignarlas a componentes o páginas específicas.
                            </li>
                            <li>Ayuda a gestionar la URL del navegador, actualizando la URL a medida que los usuarios navegan entre páginas.</li>
                            <li>Facilita el paso de parámetros (por ejemplo, IDs) de una ruta a otra.</li>
                        </ul>
                        <img class="center" loading="lazy" decoding="async" src="https://www.syncfusion.com/blogs/wp-content/uploads/2023/03/React-Router-A-Beginners-Guide-to-Essential-Navigation-Techniques.png" alt="React Router gestiona las rutas.">
                        <h4>Cómo utilizar React Router</h4>
                        <p>Para empezar a utilizar React Router, se pueden seguir estos pasos:</p>
                        <ol>
                            <li>
                                <p>Instalar la librería ejecutando</p>
                                <div id="editor20"></div>
                                <p>o</p>
                                <div id="editor21"></div>
                                <p>en el terminal.</p>
                            </li>
                            <li>
                                <p>Crear un archivo de configuración de enrutamiento JavaScript (por ejemplo, <span class="keyword">routes.js</span>) e importar React y React Router:</p>
                                <div id="editor22"></div>
                            </li>
                            <li>
                                <p>Definir las rutas utilizando el componente <span class="keyword">Route</span>. Cada ruta debe ser única y tener un componente asociado:</p>
                                <div id="editor23"></div>
                            </li>
                            <li>
                                <p>Utilizar el componente <span class="keyword">Link</span> para crear enlaces entre páginas:</p>
                                <div id="editor24"></div>
                            </li>
                            <li>
                                <p>Renderizar el componente correcto basado en la ruta actual:</p>
                                <div id="editor25"></div>
                            </li>
                        </ol>
                        <h4>Cuándo no usar React Router</h4>
                        <p>React Router es adecuado para la mayoría de las aplicaciones, pero hay algunos casos en los que se debe considerar soluciones de enrutamiento alternativas:</p>
                        <ul>
                            <li>Si la aplicación tiene una estructura de navegación muy simple y no requiere enrutamiento del lado del cliente, se puede utilizar HTML5 o JavaScript para el enrutamiento.</li>
                            <li>Si se está utilizando renderización del lado del servidor (SSR) con React, se puede usar una biblioteca como Express.js o Next.js para el enrutamiento.</li>
                        </ul>
                        <h4>Buenas prácticas</h4>
                        <p>Cuestiones a tener en cuenta cuando se utiliza React Router:</p>
                        <ul>
                            <li>Utilizar rutas significativas: Utilizar rutas de enrutamiento descriptivas y consistentes para facilitar el mantenimiento de la aplicación.</li>
                            <li>Evitar rutas anidadas: Tratar de evitar anidar rutas profundamente, ya que esto conduce a la complejidad y dificulta la depuración.</li>
                            <li>Utiliza la propiedad <span class="keyword">exact</span> prop: Al definir rutas, utilizar la prop <span class="keyword">exact</span> para asegurarse de que solo se renderizan las coincidencias de ruta exactas.</li>
                            <li>No mostrar componentes innecesarios: Renderizar solo los componentes de la ruta; evitar renderizar componentes innecesarios mediante renderizado condicional u otras técnicas.
                            </li>
                            <li>Probar la aplicación a fondo: Debe probarse a fondo la aplicación con React Router para asegurarse de que se comporta como se espera y maneja los casos extremos correctamente.
                            </li>
                        </ul>
                        <h4>Ejemplos</h4>
                        <p>Algunos ejemplos de cómo se puede usar React Router:</p>
                        <ul>
                            <li>
                                <p>Ejemplo de enrutamiento básico:</p>
                                <div id="editor26"></div>
                            </li>
                            <li>
                                <p>Ejemplo de enrutamiento parametrizado:</p>
                                <div id="editor27"></div>
                            </li>
                            <li>
                                <p>Ejemplo de rutas protegidas:</p>
                                <div id="editor28"></div>
                            </li>
                        </ul>
                        <h4>Cómo funciona</h4>
                        <figure>
                            <img class="center" loading="lazy" decoding="async" src="https://blog.theodo.com/_astro/react-router-workflow.BJwq0V6j_Z1hKM6b.webp" alt="Ejemplo de navegación con React Router.">
                            <figcaption>Ejemplo de navegación con React Router</figcaption>
                        </figure>
                        <ul>
                            <li>Cuando un usuario quiere acceder al sitio web, se realiza una solicitud <span class="keyword">GET /index.html</span> al servidor.</li>
                            <li>El servidor envía la página <span class="keyword">index.html</span> que contiene scripts para iniciar React y React Router.</li>
                            <li>La aplicación se carga en el lado del cliente.</li>
                            <li>El usuario hace clic en un botón para ir a una nueva página <span class="keyword">/foo</span>.</li>
                            <li>React Router intercepta la solicitud antes de que llegue al servidor y realiza el cambio de página, actualizando los componentes renderizados y cambiando la URL localmente.</li>
                        </ul>
                        <p>Por lo tanto, tendrá varias URL.</p>
                        <p>Sin embargo… hay un problema. Continuando con el ejemplo anterior, el usuario vio la página
                            <span class="keyword">/foo</span> y quiere compartirla: “Mira lo que acabo de encontrar. Ve a <span class="keyword">my.awesome.page.com/foo</span>”. Pero al hacer clic en el enlace solo se llega a una página 404.
                        </p>
                        <p>El servidor solo conoce la página <span class="keyword">index.html</span>. Solo React Router puede entender la solicitud <span class="keyword">GET&nbsp;my.awesome.app.com/foo</span> una vez que se carga en el lado del cliente.</p>
                        <p>De hecho, con React Router se permite a los usuarios navegar localmente a través de enlaces internos, pero solo hay un punto de entrada a la aplicación: <span class="keyword">index.html</span>. Cada vez que se solicite una página (que no sea la del
                            índice) al servidor, siguiendo un enlace, actualizándolo o escribiéndolo directamente en la barra de URL, aparecerá un error 404. Pero que no cunda el pánico, ¡existen soluciones!</p>
                        <h5>Creando una ruta general</h5>
                        <p>Una forma sencilla de manejar este problema es crear una ruta general en el servidor. El principio es bastante simple: hacer que reenvíe todas las solicitudes a <span class="keyword">index.html</span>, ya que, una vez que se carga, React Router se hará
                            cargo y realizará el enrutamiento. Es más, debería reenviar sólo las solicitudes que el servidor no encuentra, porque, en realidad, no se quiere que las solicitudes de medios, por ejemplo, sean redirigidas a <span class="keyword">index.html</span>.</p>
                        <h5>React Helmet</h5>
                        <p>Ahora hay una aplicación con varias URL y ¡todas funcionan! Genial. Sin embargo, aún queda un pequeño paso a seguir para que las páginas sean totalmente independientes. De hecho, todavía hay un <span class="keyword">index.html</span> único, por lo que son los mismos metadatos para todas las páginas. Los metadatos son cruciales para el SEO (<em lang="en">Search Engine Optimization</em>, optimización de los motores de búsqueda) y se deben tener metadatos diferentes que representen cada página. Lo que se puede hacer es usar React Helmet. Este paquete ayuda a administrar los metadatos de cada página de la aplicación agregando componentes de React al código. ¡Y es sencillo de implementar!</p>
                        <p>A continuación se muestra un ejemplo de cómo utilizar los <em>cascos</em>:</p>
                        <div id="editor29"></div>
                        <p>Con una ruta general junto con React Helmet, la aplicación ahora se compone de varias páginas, ¡todas funcionales e independientes!</p>
                        <h5>El problema JavaScript</h5>
                        <p>Todo lo anterior no cambia el hecho de que JavaScript no se rastrea bien. Este problema se puede solucionar utilizando <span class="keyword">prerender.io</span>. Esta herramienta representará el código en un navegador y guardará el HTML estático. Cuando un rastreador intente visitar el sitio web, el <em lang="en">prerender</em> se hará cargo y enviará los archivos HTML, simplificando el trabajo del rastreador.</p>
                        <h4>Conclusión</h4>
                        <p>React Router es una herramienta útil para la gestión de enrutamiento en aplicaciones React.
                            Si se usa React Router, crear una ruta general, usar React Helmet y prerenderizar ayudarán a alcanzar los <em>objetivos de posicionamiento</em>.</p>

                        <p>En este <a tabindex="0" href="https://www.youtube.com/watch?v=iF75QcoeTmw" target="_blank" rel="noreferrer noopener">video</a> podrás aclarar dudas, pero si lo tuyo es ir a la <a tabindex="0" href="https://reactrouter.com" target="_blank" rel="noreferrer noopener">fuente</a> o prefieres un <a tabindex="0" href="https://ui.dev/react-router-tutorial" target="_blank" rel="noreferrer noopener">tutorial</a> o una <a tabindex="0" href="https://www.freecodecamp.org/news/a-complete-beginners-guide-to-react-router-include-router-hooks/" target="_blank" rel="noreferrer noopener">guía</a>, tienes donde elegir.</p>
                    </div>
                </li>
                <li>
                    <h3 tabindex="-1">¿Qué son Link y NavLink en React Router?</h3>
                    <div class="contenido">
                        <img class="center" loading="lazy" decoding="async" src="https://i.ytimg.com/vi/Vu_bTKMSpbA/maxresdefault.jpg" alt="Código dinámico.">
                        <p>En React Router, <span class="keyword">Link</span> y <span class="keyword">NavLink</span> son dos componentes que se utilizan para crear enlaces que redirigen a otras rutas en la aplicación.</p>
                        <h4>Link</h4>
                        <p><span class="keyword">Link</span> es un componente que crea un enlace HTML (<span class="keyword">&lt;a&gt;</span>) que se utiliza para navegar entre diferentes rutas de la aplicación. Cuando el usuario hace clic en el enlace, React Router se encarga de mostrar la ruta destino.</p>
                        <p>Ejemplo:</p>
                        <div id="editor30"></div>
                        <h5>Consejos</h5>
                        <ul>
                            <li><strong>Ruta incorrecta</strong> es, probablemente, el problema más común. Es debido a la ruta incorrecta proporcionada en la prop <span class="keyword">to</span> del <span class="keyword">Link</span>. Hay que asegurarse que la ruta proporcionada en el <span class="keyword">Link</span> coincide con la ruta definida en <span class="keyword">Route</span>.</li>
                            <li><strong>Anidar enlaces</strong> es otro error común que lleva a un comportamiento
                                <em>inesperado</em>. Según la especificación HTML5, no se permite el anidamiento de etiquetas de anclaje. Dado que <span class="keyword">Link</span> se traduce en una etiqueta de anclaje, también está prohibido anidar Links en React Router.
                            </li>
                            <li><strong>Usar la etiqueta <span class="keyword">&lt;a&gt;</span> en lugar de <span class="keyword">Link</span></strong> para la navegación es un error, porque al hacer clic en una etiqueta <span class="keyword">&lt;a&gt;</span> se refresca toda la página, mientras que al hacer clic en un <span class="keyword">Link</span> solo se vuelve a renderizar el componente necesario. Siempre hay que usar <span class="keyword">Link</span> para la navegación en las aplicaciones de React.</li>
                            <li>Usar la prop <span class="keyword">replace</span> de <span class="keyword">Link</span> cuando no se quiera mantener el historial de la URL actual.</li>
                        </ul>
                        <h4>NavLink</h4>
                        <p><span class="keyword">NavLink</span> es similar a <span class="keyword">Link</span>, pero con una diferencia importante: agrega una clase CSS por defecto, llamada <span class="keyword">active</span>, cuando la ruta destino coincide con la ruta actual. Esto permite dar estilo al enlace activo y distinguirlo de los demás.</p>
                        <p>Ejemplo:</p>
                        <div id="editor31"></div>
                        <p>Así pues, la principal diferencia entre <span class="keyword">Link</span> y <span class="keyword">NavLink</span> es que <span class="keyword">Link</span> no añade nada más al elemento <span class="keyword">&lt;a&gt;</span>, mientras que <span class="keyword">NavLink</span> agrega un estilo por defecto (una clase CSS) para distinguir los enlaces de navegación.</p>
                        <p>Se puede personalizar el nombre de la clase CSS que se añade al enlace activo mediante la propiedad <span class="keyword">exact</span> (ver más abajo).</p>
                        <h4>Propiedades</h4>
                        <p>Ambos componentes tienen algunas propiedades importantes:</p>
                        <ul>
                            <li><span class="keyword">to</span>: La ruta destino a la que se navegará cuando el usuario haga clic en el enlace.</li>
                            <li><span class="keyword">exact</span> (opcional): Si es verdadero, el enlace solo se considera activo si la ruta destino coincide exactamente con la ruta actual. De lo contrario, el enlace se considera activo si la ruta destino comienza con la ruta actual.
                            </li>
                            <li><span class="keyword">className</span> (opcional): Un nombre de clase CSS adicional que se añade al elemento <span class="keyword">&lt;a&gt;</span>.</li>
                        </ul>
                        <p>Ejemplo:</p>
                        <div id="editor32"></div>
                        <p>En este ejemplo, se ha utilizado <span class="keyword">NavLink</span> en lugar de <span class="keyword">Link</span> para mostrar una navegación en línea. La propiedad <span class="keyword">exact</span> se utiliza para indicar que el enlace debe coincidir exactamente con la ruta actual. Esto significa que el enlace solo se marcará como activo cuando la ruta actual coincida exactamente con la ruta especificada en el enlace.</p>
                        <p>También se ha usado <span class="keyword">Link</span> para crear enlaces normales que no tienen la propiedad <span class="keyword">exact</span>. Estos enlaces no tendrán la propiedad <span class="keyword">activeClassName</span> ni <span class="keyword">activeStyle</span> por defecto, por lo que tendrán un aspecto diferente cuando sean pulsados.</p>
                        <div id="editor33"></div>
                        <p>En este otro ejemplo, el prop <span class="keyword">activeStyle</span> se utiliza para aplicar un estilo específico al enlace cuando está activo, y el prop <span class="keyword">activeClassName</span> se utiliza para agregar una clase CSS al enlace,
                            también cuando está activo.</p>
                        <p>El componente <span class="keyword">Link</span> se utiliza para enlaces externos y no tiene los props <span class="keyword">exact</span>, <span class="keyword">activeStyle</span> ni
                            <span class="keyword">activeClassName</span>.
                        </p>
                        <h4 id="conclusion">Conclusión</h4>
                        <p>En resumen, <span class="keyword">Link</span> es un componente básico para crear enlaces,
                            mientras que <span class="keyword">NavLink</span> agrega estilo por defecto y permite distinguir los enlaces activos de los inactivos. Sin embargo, en ambos casos, hay que tener cuidado para evitar trampas y errores comunes.</p>

                        <p>Este <a tabindex="0" href="https://www.youtube.com/watch?v=UjAmXiNE68E" target="_blank" rel="noreferrer noopener">video</a> y este otro <a tabindex="0" href="https://www.youtube.com/watch?v=Vu_bTKMSpbA" target="_blank" rel="noreferrer noopener">video</a> te podrán aclarar dudas, pero si te gusta acudir a la <a tabindex="0" href="https://reactrouter.com/en/main/components/nav-link" target="_blank" rel="noreferrer noopener">fuente</a> y <a tabindex="0" href="https://medium.com/@alexanie_/navlink-component-in-react-router-b83f4a11794f" target="_blank" rel="noreferrer noopener">leer</a>.
                        </p>
                    </div>
                </li>
                <li>
                    <h3 tabindex="-1">¿Cómo se manejan los formularios en React?</h3>
                    <div class="contenido">
                        <img class="center" loading="lazy" decoding="async" src="https://i.ytimg.com/vi/QprMh3YNYWA/maxresdefault.jpg" alt="Formularios en React.">
                        <p>En React, el manejo de formularios puede ser un poco complicado debido a la naturaleza asincrónica y el uso de componentes funcionales que React proporciona. Sin embargo, hay algunas estrategias y librerías que se pueden utilizar para manejar formularios de manera efectiva.</p>
                        <img class="center" loading="lazy" decoding="async" src="https://media.graphassets.com/oBAngFt2RHegnUpF8lSh" alt="Ejemplo de formulario de usuario.">
                        <p>Veamos un ejemplo básico:</p>
                        <ol>
                            <li>
                                <p>Definir el estado inicial:</p>
                                <div id="editor40"></div>
                            </li>
                            <li>
                                <p>Crear una función de manejo de eventos para actualizar el estado:</p>
                                <div id="editor41"></div>
                            </li>
                            <li>
                                <p>Utilizar el estado en los campos de entrada del formulario:</p>
                                <div id="editor42"></div>
                            </li>
                            <li>
                                <p>Utilizar el estado en el controlador de envío del formulario:</p>
                                <div id="editor43"></div>
                            </li>
                        </ol>
                        <p>Supongamos un componente <span class="keyword">Form</span> que contiene un campo de texto y un botón para enviar el formulario:</p>
                        <div id="editor44"></div>
                        <p>En este ejemplo, se utiliza el hook <span class="keyword">useState</span> para almacenar los valores del formulario en el estado. Cuando el usuario hace cambios en el formulario y presiona el botón enviar, el evento <span class="keyword">handleSubmit</span>
                            es llamado y se imprime un mensaje en la consola con los valores del formulario.</p>
                        <p>Pero, este es solo un ejemplo básico de cómo se manejan los formularios en React. Hay muchas más características y enfoques que se pueden utilizar, como validación de formularios,
                            manejo de errores y uso de bibliotecas de formularios más avanzadas.</p>
                        <h4>Estrategias para manejar formularios en React</h4>
                        <ul>
                            <li>Se Puede utilizar un estado (<em lang="en">state</em>) para almacenar los valores del formulario y actualizarlo cuando el usuario hace cambios.</li>
                            <li>Hay varias bibliotecas como Formik, Final Form, y React Hook Form que te permiten manejar formularios de manera sencilla y eficiente.</li>
                            <li>Se puede utilizar Context para compartir la información del formulario entre componentes.</li>
                        </ul>
                        <h4>Bibliotecas de formularios populares</h4>
                        <ul>
                            <li>
                                <p>Formik: Es una biblioteca popular para manejar formularios en React. Te permite validar tus formularios y hacer que sean más seguros.</p>
                                <img class="center" loading="lazy" decoding="async" src="https://blog.logrocket.com/wp-content/uploads/2019/10/formik-re-renders.gif" alt="Formik, ejemplo.">
                            </li>
                            <li>
                                <p>Final Form: Es otra biblioteca popular para manejar formularios en React. Te permite crear formularios complejos con facilidad.</p>
                                <img class="center" loading="lazy" decoding="async" src="https://user-images.githubusercontent.com/5987056/147809011-7257fa48-2f33-497d-a1f6-ad8bbb9a3b62.gif" alt="Final Form, ejemplo.">
                            </li>
                            <li>
                                <p>React Hook Form: Es una biblioteca que te permite manejar formularios de manera eficiente utilizando hooks.</p>
                                <img class="center" loading="lazy" decoding="async" src="https://raw.githubusercontent.com/bluebill1049/react-hook-form/master/docs/v7_example.gif" alt="React Hook Form, ejemplo.">
                            </li>
                        </ul>
                        <h4>Consejos</h4>
                        <ul>
                            <li>Utiliza un estado para almacenar los valores del formulario y actualizarlo cuando el usuario hace cambios.</li>
                            <li>Asegúrate de validar tus formularios para evitar errores y problemas de seguridad.</li>
                            <li>Si necesitas manejar formularios complejos, considera utilizar una biblioteca de formularios como Formik o Final Form.</li>
                            <li>Asegúrate de que tu formulario sea accessible para todos los usuarios, incluyendo aquellos con discapacidades.</li>
                        </ul>
                        <h4>Conclusión</h4>
                        <p>El manejo de formularios en React puede ser un poco complicado, pero hay varias estrategias y bibliotecas que se pueden utilizar para hacerlo más fácil. Conviene recordar que hay que validar los formularios y asegurarse de que sean accesibles para todos los usuarios.</p>

                        <h4>¿Cómo ampliar?</h4>
                        <p>Para más datos, puedes recurrir a la <a tabindex="0" href="https://javascript.19633.com/es/React-3/1003046967.html" target="_blank" rel="noreferrer noopener">guía</a> o ver el <a tabindex="0" href="https://www.youtube.com/watch?v=PhddxZmnv0Y" target="_blank" rel="noreferrer noopener">video</a> o este <a tabindex="0" href="https://www.youtube.com/watch?v=QprMh3YNYWA" target="_blank" rel="noreferrer noopener">otro</a>.</p>
                    </div>
                </li>
                <li>
                    <h3 tabindex="-1">¿Qué son los ciclos de vida en React?</h3>
                    <div class="contenido">
                        <img class="center" loading="lazy" decoding="async" src="https://cinthialandia.com/static/f92e32367100fedd3ead639807783a3f/f3583/life-cycles-es.png" alt="Ciclos de vida en React.">
                        <p>En React, un ciclo de vida (o <em lang="en">lifecycle</em>) se refiere a las etapas por las que pasa un componente cuando es creado, modificado o eliminado. Hay varias etapas importantes en el ciclo de vida de un componente React:</p>
                        <ul>
                            <li>
                                <p><strong>Montaje</strong>: El componente se crea y se agrega al DOM.</p>
                                <ul>
                                    <li>
                                        <p><a tabindex="0" href="https://es.react.dev/reference/react/Component#constructor" target="_blank" rel="noreferrer noopener">constructor(props)</a>:
                                            La primera función llamada cuando se crea el componente. Aquí es donde se inicializa el estado del componente utilizando <span class="keyword">this.state</span>. También se puede asignar manejadores de eventos y realizar otras inicializaciones.</p>
                                        <div id="editor50"></div>
                                    </li>
                                    <li>
                                        <p><a tabindex="0" href="https://es.react.dev/reference/react/Component#componentdidmount" target="_blank" rel="noreferrer noopener">componentDidMount()</a>: se ejecuta automáticamente después de que el componente se haya montado en el DOM.
                                            Dentro de este método, se puede realizar cualquier acción necesaria, como realizar una llamada a una API, añadir eventos, o inicializar alguna funcionalidad adicional.
                                            Señalar que <span class="keyword">componentDidMount</span> solo se ejecuta una vez, cuando el componente se monta por primera vez. Si es necesario realizar alguna acción cada vez que el componente se actualiza, hay que utilizar otros métodos de ciclo de vida como <span class="keyword">componentDidUpdate</span>.</p>
                                        <div id="editor51"></div>
                                    </li>
                                    <li>
                                        <p><a tabindex="0" href="https://es.react.dev/reference/react/Component#static-getderivedstatefromprops" target="_blank" rel="noreferrer noopener">static getDerivedStateFromProps(props, state)</a>:
                                            Actualiza el estado del componente según los props recibidos. Se utiliza principalmente para manejar cambios en las props que pueden requerir una actualización en el estado. Probablemente <a tabindex="0" href="https://es.legacy.reactjs.org/blog/2018/06/07/you-probably-dont-need-derived-state.html" target="_blank" rel="noreferrer noopener">no sea necesario</a>.</p>
                                        <div id="editor52"></div>
                                    </li>
                                    <li>
                                        <p><a tabindex="0" href="https://es.react.dev/reference/react/Component#render" target="_blank" rel="noreferrer noopener"><strong>render()</strong></a>:
                                            El método <span class="keyword">render</span> es donde el componente se renderiza en la pantalla, es obligatorio y se encarga de devolver el JSX que representa el componente. Aquí se accede al estado y a las props del componente para renderizar el contenido.</p>
                                        <div id="editor53"></div>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Actualización</strong>: El componente ya existe y necesita ser actualizado con nuevos datos o por cambios en los props.</p>
                                <ul>
                                    <li>
                                        <p><span class="keyword">componentWillUpdate(nextProps, nextState)</span> <a tabindex="0" href="https://es.react.dev/reference/react/Component#componentwillupdate" target="_blank" rel="noreferrer noopener">(Obsoleto)</a>: se ejecuta antes de que el componente se actualice. Si necesitas realizar acciones después de que se produzca la actualización, puedes usar el método <span class="keyword">componentDidUpdate</span> en su lugar. Además, se considera obsoleto en las versiones más recientes de React y se recomienda usar <span class="keyword">componentDidUpdate</span> en su lugar.</p>
                                        <div id="editor54_0"></div>
                                    </li>
                                    <li>
                                        <p><a tabindex="0" href="https://es.react.dev/reference/react/Component#componentdidupdate" target="_blank" rel="noreferrer noopener">componentDidUpdate(prevProps, prevState, snapshot?)</a>: se ejecuta después de que el componente se haya renderizado y actualizado. Si necesitas realizar acciones antes de que se produzca la actualización, puedes usar el método <span class="keyword">componentWillUpdate</span> <a tabindex="0" href="https://es.react.dev/reference/react/Component#componentwillupdate" target="_blank" rel="noreferrer noopener">(Obsoleto)</a> en su lugar.</p>
                                        <div id="editor54_1"></div>
                                    </li>
                                    <li>
                                        <p><a tabindex="0" href="https://es.react.dev/reference/react/Component#static-getderivedstatefromprops" target="_blank" rel="noreferrer noopener">static getDerivedStateFromProps(props, state)</a>: Actualiza el estado del componente según los props recibidos.</p>
                                    </li>
                                    <li>
                                        <p><a tabindex="0" href="https://es.react.dev/reference/react/Component#shouldcomponentupdate" target="_blank" rel="noreferrer noopener">shouldComponentUpdate(nextProps, nextState, nextContext)</a>: Decide si el componente debe ser actualizado o no. Si este método devuelve false, el renderizado se omite. Se puede utilizar esta función para optimizar el rendimiento al evitar renderizados innecesarios.</p>
                                        <div id="editor54"></div>
                                    </li>
                                    <li>
                                        <p><a tabindex="0" href="https://es.react.dev/reference/react/Component#render" target="_blank" rel="noreferrer noopener"><strong>render()</strong></a>: El método <span class="keyword">render</span> es donde el componente se renderiza de nuevo.</p>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Desmontaje</strong>: El componente ya no es necesario y necesita ser eliminado del DOM.</p>
                                <ul>
                                    <li>
                                        <p><a tabindex="0" href="https://es.react.dev/reference/react/Component#componentwillunmount" target="_blank" rel="noreferrer noopener">componentWillUnmount()</a>: La última función llamada antes de que el componente sea eliminado del DOM. Aquí se pueden realizar tareas de limpieza, como cancelar solicitudes de red o eliminar temporizadores.</p>
                                        <div id="editor55"></div>
                                    </li>
                                    <li>
                                        <p><span class="keyword">componentDidUnmount</span> <a tabindex="0" href="https://github.com/preactjs/preact/issues/288#issuecomment-264603165" target="_blank" rel="noreferrer noopener"><strong>(Obsoleto)</strong></a>:
                                            Se llama después de que el componente ha sido eliminado del DOM. No se debe realizar ninguna acción en este método, ya que el componente ya no está presente.</p>
                                        <div id="editor56"></div>
                                    </li>
                                </ul>
                            </li>
                            <li>
                                <p><strong>Manejo de errores</strong>: El componente ha tenido un error y necesita ser tratado.</p>
                                <ul>
                                    <li>
                                        <p><a tabindex="0" href="https://es.react.dev/reference/react/Component#componentdidcatch" target="_blank" rel="noreferrer noopener">componentDidCatch(error,
                                                info)</a>: Se llama cuando el componente ha tenido un error que necesita ser tratado. Puede utilizarse para manejar errores y mostrar un mensaje de error al usuario.</p>
                                        <div id="editor57"></div>
                                    </li>
                                </ul>
                            </li>
                        </ul>
                        <div class="divwarning">
                            <h4 class="h4warnig">
                                <svg class="svgwarning" viewBox="0 0 72 72" xmlns="http://www.w3.org/2000/svg">
                                    <g clip-path="url(#clip0_738_836)">
                                        <path fill-rule="evenodd" clip-rule="evenodd" d="M27 48L27 57.3409L40.0772 48L55.6975 48C57.1595 48 58.1986 47.0112 58.3851 45.8604C59.1824 40.9398 60 34.619 60 29.625C60 24.7282 59.2125 18.7546 58.4302 14.0813C58.2445 12.9721 57.2326 12 55.7805 12L16.2195 12C14.7674 12 13.7555 12.9721 13.5698 14.0813C12.7875 18.7546 12 24.7282 12 29.625C12 34.619 12.8176 40.9398 13.6149 45.8604C13.8014 47.0112 14.8404 48 16.3025 48H27ZM42 54H55.6975C59.9534 54 63.6271 51.0213 64.3078 46.8201C65.1161 41.8322 66 35.1209 66 29.625C66 24.2196 65.1449 17.8522 64.3478 13.0906C63.6513 8.93026 59.9987 6 55.7805 6H16.2195C12.0013 6 8.34867 8.93026 7.65218 13.0906C6.85505 17.8522 6 24.2196 6 29.625C6 35.1209 6.88391 41.8322 7.69215 46.8201C8.37291 51.0213 12.0466 54 16.3025 54H21L21 63.1704C21 65.6106 23.7581 67.0299 25.7437 65.6116L42 54ZM39 39.3686C39 40.9422 38 41.9912 36 41.9912C34 41.9912 33 40.9422 33 39.3686C33 37.7951 34 36.746 36 36.746C38 36.746 39 37.7951 39 39.3686ZM38.1771 20.2412C38.1771 18.9986 37.1697 17.9912 35.9271 17.9912C34.6845 17.9912 33.6771 18.9986 33.6771 20.2412V31.5956C33.6771 32.8382 34.6845 33.8456 35.9271 33.8456C37.1697 33.8456 38.1771 32.8382 38.1771 31.5956V20.2412Z" fill="currentColor"></path>
                                    </g>
                                    <defs>
                                        <clipPath id="clip0_738_836">
                                            <rect width="72" height="72" fill="white"></rect>
                                        </clipPath>
                                    </defs>
                                </svg>
                                Atención
                            </h4>
                            <p class="pmensajewarning">Es recomendable definir los componentes como funciones en lugar de clases. <a class="awarning" href="#migrating-a-simple-component-from-a-class-to-a-function">Mira cómo migrar.</a></p>
                        </div>
                        <img class="center" loading="lazy" decoding="async" src="https://reactiveprogramming.io/figures/react/ciclo-de-vida-nuevo.png" alt="Ciclo de vida de los componentes.">
                        <p>Ejemplo <em>esquelético</em>:</p>
                        <div id="editor58"></div>
                        <p>En este ejemplo, se crea un componente <span class="keyword">Example</span> que tiene un estado <span class="keyword">count</span> inicializado en 0. El componente tiene varios métodos que se llaman según el ciclo de vida. Se utiliza el hook <span class="keyword">useState</span> para gestionar el estado del componente y el hook <span class="keyword">useEffect</span> para realizar tareas que se necesitan efectuar, como registrar mensajes en la consola, además, también tiene la capacidad de realizar limpieza al retornar una función en el <em lang="en">callback</em>.</p>
                        <p>En este otro ejemplo, hay dos componentes: <span class="keyword">MyComponent</span> y <span class="keyword">MyFunctionalComponent</span>. Ambos muestran un contador y un botón para incrementar el contador.</p>
                        <div id="editor59"></div>
                        <p>En <span class="keyword">MyComponent</span>, los métodos del ciclo de vida son métodos de la clase. Mientras que en <span class="keyword">MyFunctionalComponent</span>, aparecen, de nuevo, <span class="keyword">useState</span> y <span class="keyword">useEffect</span> para realizar las tareas mencionadas en el ejemplo anterior (gestionar el estado, registrar mensajes en la consola y limpiar).</p>
                        <p>Estos ciclos de vida permiten controlar el flujo de los componentes React y realizar tareas importantes como la inicialización, la actualización y la eliminación.</p>

                        <p>¡¿Te has quedado con ganas de más?! En este <a tabindex="0" href="https://cinthialandia.com/es/blog/life-cycles/" target="_blank" rel="noreferrer noopener">artículo</a> y en este
                            <a tabindex="0" href="https://www.youtube.com/watch?v=HmudQUYnQQg" target="_blank" rel="noreferrer noopener">video</a> te lo pueden aclarar… o no.
                        </p>
                    </div>
                </li>
            </ul>
        </article>
    </main>
    <script defer src="./js/checkpoint_18.js"></script>
    <script defer src="https://codemirror.net/codemirror.js"></script>
    <script defer src="./js/cm6editor.js"></script>
</body>

</html>