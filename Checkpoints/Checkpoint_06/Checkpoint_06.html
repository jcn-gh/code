<!DOCTYPE html>
<html lang="es">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Checkpoint 6</title>
</head>

<body>
    <h2>Checkpoint 6</h2>

    <p>Este checkpoint consta de dos partes:</p>
    <ul>
        <li>
            <p>Una primera parte que es similar al checkpoint anterior, las preguntas hay que realizar una "documentación", lo más completa posible</p>
            <ul>
                <li>
                    <h3>¿Para qué usamos Classes en Python?</h3>
                    <p>Las clases en Python se utilizan para crear objetos y organizar la funcionalidad relacionada en un solo lugar. Algunas de las razones por las que se utilizan clases en Python son:</p>
                    <ul>
                        <li><b>Abstracción</b>: Las clases permiten representar entidades del mundo real o conceptos abstractos como objetos con propiedades y comportamientos específicos.
                            <pre><code>from abc import ABC, abstractmethod

class Device(ABC):
    def __init__(self, name):
        self.name = name

    @abstractmethod
    def turn_on(self):
        pass

    @abstractmethod
    def turn_off(self):
        pass

class Light(Device):
    def turn_on(self):
        return "Light turned on"

    def turn_off(self):
        return "Light turned off"

class Fan(Device):
    def turn_on(self):
        return "Fan turned on"

    def turn_off(self):
        return "Fan turned off"

# Crear instancias de las clases
light = Light("Living room light")
fan = Fan("Ceiling fan")

# Encender y apagar los dispositivos
print(f"{light.name}: {light.turn_on()}")  # Esto imprimirá "Living room light: Light turned on"
print(f"{fan.name}: {fan.turn_off()}")  # Esto imprimirá "Ceiling fan: Fan turned off"</code></pre>
                            <p>En este ejemplo, la clase <code>Device</code> es una clase abstracta que define métodos abstractos <code>turn_on</code> y <code>turn_off</code>. Las clases <code>Light</code> y <code>Fan</code> heredan de <code>Device</code> y proporcionan implementaciones concretas de estos métodos. Esto permite abstraer el comportamiento de encendido y apagado, mientras que las clases hijas proporcionan implementaciones específicas para diferentes tipos de dispositivos.</p>
                        </li>
                        <li><b>Encapsulación</b>: Las clases permiten encapsular datos y funciones relacionadas en un solo objeto, lo que facilita la gestión y el mantenimiento del código.
                            <pre><code>class Person:
    def __init__(self, name, age):
        self._name = name  # Atributo protegido
        self.__age = age  # Atributo privado

    def display_info(self):
        return f"Nombre: {self._name}, Edad: {self.__age}"

    def get_age(self):
        return self.__age

    def set_age(self, age):
        if age &gt; 0:
            self.__age = age

# Crear una instancia de la clase
person = Person("Alice", 30)

# Acceder a los atributos protegidos y privados
print(person._name)  # Esto imprimirá "Alice"
# print(person.__age)  # Esto generará un error, ya que el atributo es privado

# Acceder a los métodos para obtener y establecer el atributo privado
print(person.get_age())  # Esto imprimirá "30"
person.set_age(35)
print(person.get_age())  # Esto imprimirá "35"

# Intentar establecer una edad negativa
person.set_age(-1)
print(person.get_age())  # Esto imprimirá "35", ya que la validación impide establecer una edad negativa</code></pre>
                            <p>En este ejemplo, la clase <code>Person</code> tiene un atributo protegido <code>_name</code> y un atributo privado <code>__age</code>. También proporciona métodos para acceder y modificar el atributo privado <code>__age</code>, lo que permite encapsular el acceso a los datos internos de la clase.</p>
                        </li>
                        <li><b>Reutilización de código</b>: Las clases permiten crear objetos que pueden ser reutilizados en diferentes partes del programa, evitando la duplicación de código.
                            <pre><code>class Employee:
    def __init__(self, name, salary):
        self.name = name
        self.salary = salary

    def display_info(self):
        return f"Empleado: {self.name}, Salario: {self.salary}"

class Manager(Employee):
    def __init__(self, name, salary, department):
        super().__init__(name, salary)
        self.department = department

    def display_info(self):
        return f"Manager: {self.name}, Salario: {self.salary}, Departamento: {self.department}"

class Developer(Employee):
    def __init__(self, name, salary, programming_language):
        super().__init__(name, salary)
        self.programming_language = programming_language

    def display_info(self):
        return f"Desarrollador: {self.name}, Salario: {self.salary}, Lenguaje de programación: {self.programming_language}"

# Crear instancias de las clases
manager = Manager("Alice", 80000, "IT")
developer = Developer("Bob", 60000, "Python")

# Mostrar la información de cada empleado
print(manager.display_info())  # Esto imprimirá "Manager: Alice, Salario: 80000, Departamento: IT"
print(developer.display_info())  # Esto imprimirá "Desarrollador: Bob, Salario: 60000, Lenguaje de programación: Python"</code></pre>
                            <p>En este ejemplo, la clase <code>Employee</code> contiene información básica sobre un empleado y el método <code>display_info</code> para mostrar la información del empleado. Las clases <code>Manager</code> y <code>Developer</code> heredan de <code>Employee</code> y proporcionan sus propias implementaciones del método <code>display_info</code>, lo que permite reutilizar el código para mostrar la información de diferentes roles de empleados.</p>
                        </li>
                        <li><b>Herencia</b>: Las clases pueden heredar propiedades y métodos de otras clases, lo que permite crear jerarquías de clases y compartir funcionalidad común.
                            <pre><code>class Vehiculo:
    def __init__(self, marca, modelo):
        self.marca = marca
        self.modelo = modelo

    def obtener_info(self):
        return f"Marca: {self.marca}, Modelo: {self.modelo}"

class Automovil(Vehiculo):
    def __init__(self, marca, modelo, color):
        super().__init__(marca, modelo)
        self.color = color

    def obtener_info(self):
        return f"Marca: {self.marca}, Modelo: {self.modelo}, Color: {self.color}"

class Motocicleta(Vehiculo):
    def __init__(self, marca, modelo, cilindrada):
        super().__init__(marca, modelo)
        self.cilindrada = cilindrada

    def obtener_info(self):
        return f"Marca: {self.marca}, Modelo: {self.modelo}, Cilindrada: {self.cilindrada}cc"

automovil = Automovil("Toyota", "Corolla", "Rojo")
motocicleta = Motocicleta("Honda", "CBR", 500)

print(automovil.obtener_info())    # Imprime "Marca: Toyota, Modelo: Corolla, Color: Rojo"
print(motocicleta.obtener_info())  # Imprime "Marca: Honda, Modelo: CBR, Cilindrada: 500cc"
</code></pre>
                            <p>En este ejemplo, tenemos una clase base llamada "Vehiculo" que tiene un constructor para inicializar la marca y el modelo del vehículo, y un método "obtener_info" que devuelve una cadena con la información del vehículo.</p>
                            <p>Luego, creamos dos clases derivadas, "Automovil" y "Motocicleta", que heredan de la clase "Vehiculo". Estas clases sobrescriben el método "obtener_info" para agregar información adicional específica de cada tipo de vehículo.</p>
                            <p>Cuando creamos objetos de las clases "Automovil" y "Motocicleta", heredan las propiedades y métodos de la clase "Vehiculo". Podemos llamar al método "obtener_info" en cada objeto y obtendremos la información específica de cada tipo de vehículo, incluyendo el color para los automóviles y la cilindrada para las motocicletas.</p>
                            <p>En resumen, la herencia nos permite crear jerarquías de clases y compartir funcionalidad común entre ellas. Las clases derivadas pueden heredar propiedades y métodos de la clase base, y también pueden sobrescribir o agregar nuevos métodos para adaptarse a su comportamiento específico. Esto nos permite reutilizar código y organizar nuestra estructura de clases de manera más eficiente.</p>
                        </li>
                        <li><b>Polimorfismo</b>: Las clases en Python permiten el polimorfismo, lo que significa que diferentes objetos pueden responder de manera diferente a la misma llamada de método.
                            <pre><code>class Vehiculo:
    def moverse(self):
        pass

class Automovil(Vehiculo):
    def moverse(self):
        print("El automóvil se desplaza por la carretera.")

class Avion(Vehiculo):
    def moverse(self):
        print("El avión vuela por el cielo.")

def moverse_vehiculo(vehiculo):
    vehiculo.moverse()

automovil = Automovil()
avion = Avion()

moverse_vehiculo(automovil)  # Imprime "El automóvil se desplaza por la carretera."
moverse_vehiculo(avion)     # Imprime "El avión vuela por el cielo."
</code></pre>
                            <p>En este ejemplo, tenemos una clase base llamada "Vehiculo" con un método llamado "moverse" que no hace nada. Luego, creamos dos clases derivadas, "Automovil" y "Avion", que heredan de la clase "Vehiculo" y sobrescriben el método "moverse" para imprimir diferentes mensajes de movimiento.</p>
                            <p>La función "moverse_vehiculo" toma un objeto de tipo "Vehiculo" como argumento y llama al método "moverse" en ese objeto. Dependiendo del tipo de objeto que se pase a la función, se imprimirá un mensaje de movimiento diferente.</p>
                            <p>En resumen, el polimorfismo nos permite tratar diferentes objetos de manera uniforme a través de una interfaz común, pero cada objeto puede tener su propia implementación específica del método. Esto nos brinda flexibilidad para trabajar con diferentes tipos de objetos y realizar acciones específicas según el tipo de objeto.</p>
                        </li>
                    </ul>
                    <p>Imagina que estás construyendo un programa para administrar una biblioteca. Aquí hay algunos ejemplos de cómo las clases en Python pueden ser útiles en este escenario:</p>
                    <ul>
                        <li>Clase "Libro":
                            <ul>
                                <li>Puedes crear una clase llamada "Libro" para representar cada libro en la biblioteca.</li>
                                <li>La clase "Libro" puede tener propiedades como "título", "autor" y "año de publicación".</li>
                                <li>También puede tener métodos como "prestar()" y "devolver()" para realizar acciones específicas en un libro.</li>
                            </ul>
                        </li>
                        <li>Clase "Biblioteca":
                            <ul>
                                <li>Puedes crear una clase llamada "Biblioteca" para representar la biblioteca en sí.</li>
                                <li>La clase "Biblioteca" puede tener propiedades como "nombre" y "ubicación".</li>
                                <li>También puede tener métodos como "agregar_libro()" y "buscar_libro()" para administrar los libros en la biblioteca.</li>
                            </ul>
                        </li>
                        <li>Clase "Usuario":
                            <ul>
                                <li>Puedes crear una clase llamada "Usuario" para representar a las personas que utilizan la biblioteca.</li>
                                <li>La clase "Usuario" puede tener propiedades como "nombre" y "número de identificación".</li>
                                <li>También puede tener métodos como "tomar_prestado()" y "devolver_libro()" para que los usuarios interactúen con los libros.</li>
                            </ul>
                        </li>
                    </ul>
                    <p>Estos son solo ejemplos básicos, pero muestran cómo las clases en Python nos permiten modelar entidades del mundo real y organizar la funcionalidad relacionada en un solo lugar. Al utilizar clases, podemos crear objetos que representen libros, bibliotecas y usuarios, y definir cómo interactúan entre sí. Esto hace que nuestro código sea más organizado, reutilizable y fácil de mantener.</p>
                    <p>En resumen, las clases en Python son utilizadas para crear objetos, organizar la funcionalidad relacionada y facilitar la reutilización y el mantenimiento del código.</p>
                </li>
                <li>
                    <h3>¿Qué método se ejecuta automáticamente cuando se crea una instancia de una clase?</h3>
                    <p>El método <code>__init__</code> es un método especial de Python que se ejecuta automáticamente cuando se crea una instancia de una clase. Se utiliza para inicializar los atributos de la instancia.</p>
                    <p>Un ejemplo sencillo:</p>
                    <pre><code>class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

persona1 = Persona("Juan", 25)
print(persona1.nombre)  # Salida: Juan
print(persona1.edad)    # Salida: 25</code></pre>
                    <p>En este ejemplo, cuando creamos una instancia de la clase <code>Persona</code>, el método <code>__init__</code> se ejecuta automáticamente, inicializando los atributos <code>nombre</code> y <code>edad</code> con los valores proporcionados.</p>
                    <p>El método <code>__init__</code> también se conoce como el "constructor" de la clase, ya que se encarga de inicializar los atributos de la instancia cuando ésta se crea. Es un lugar apropiado para realizar cualquier configuración inicial que la instancia pueda necesitar.</p>
                    <p>Además, el método <code>__init__</code> puede aceptar parámetros además del parámetro <code>self</code>, lo que le permite inicializar la instancia con valores específicos y puede llamar a otros métodos de la clase para realizar tareas de inicialización más complejas. También puede tener valores por defecto para los parámetros, lo que permite crear instancias con algunos atributos predefinidos si no se proporcionan valores específicos al crear la instancia.</p>
                    <p>Por último, es importante recordar que el uso de doble guion bajo (underscore) al inicio y al final del nombre del método (<code>__init__</code>) indica que es un método especial en Python y no se debe crear un método con un nombre similar para otros fines. Igualmente, hay que tener en cuenta que el método <code>__init__</code> no es el único método especial en Python. Hay otros métodos como <code>__str__</code>, <code>__repr__</code>, <code>__eq__</code>... que también proporcionan comportamientos especiales a las clases y sus instancias.</p>
                </li>
                <li>
                    <h3>¿Cuáles son los tres verbos de API?</h3>
                    <p>Ver documentación en <a href="https://es.wikipedia.org/wiki/API">Wikipedia</a> o en <a href="https://developer.mozilla.org/es/docs/Learn/JavaScript/Client-side_web_APIs/Introduction">MDN</a></p>
                </li>
                <li>
                    <h3>¿Es MongoDB una base de datos SQL o NoSQL?</h3>
                    <p>MongoDB es una base de datos NoSQL, lo que significa que no utiliza el lenguaje de consulta estructurado (SQL) para realizar consultas y manipular los datos. En cambio, utiliza un modelo de datos flexible basado en documentos.</p>
                    <p>Estas son algunas características clave de MongoDB que lo distinguen de las bases de datos SQL:</p>
                    <ul>
                        <li><b>Flexibilidad</b> (Modelo de datos flexible): MongoDB almacena los datos en documentos BSON (Binary JSON), que son estructuras de datos similares a JSON. Estos documentos pueden tener una estructura flexible, lo que significa que no es necesario seguir un esquema fijo como en las bases de datos SQL.</li>
                        <li><b>Escalabilidad horizontal</b>: MongoDB está diseñado para escalar horizontalmente, lo que significa que puede manejar grandes volúmenes de datos distribuyendo la carga en múltiples servidores. Esto permite un mejor rendimiento y capacidad de almacenamiento a medida que los datos crecen.</li>
                        <li><b>Consultas ricas</b>: MongoDB ofrece una amplia gama de operaciones de consulta y búsqueda, como consultas por campo, consultas de rango, consultas de texto completo y consultas geoespaciales. Estas operaciones permiten realizar consultas complejas y obtener resultados rápidos.</li>
                        <li><b>Alta disponibilidad</b>: MongoDB proporciona mecanismos para garantizar la alta disponibilidad de los datos, como la replicación automática y el enrutamiento automático de consultas. Esto asegura que los datos estén siempre disponibles incluso en caso de fallos del servidor.</li>
                    </ul>
                    <p>Aquí hay un ejemplo para ilustrar cómo se vería una consulta en MongoDB en comparación con una consulta SQL:</p>
                    <p>Consulta SQL:<br> <code>SELECT * FROM usuarios WHERE edad &gt; 25</code></p>
                    <p>Consulta MongoDB:<br> <code>db.usuarios.find({ edad: { $gt: 25 } })</code></p>
                    <p>En resumen, MongoDB es una base de datos NoSQL que ofrece flexibilidad en el modelo de datos, escalabilidad horizontal, consultas ricas y alta disponibilidad.</p>
                </li>
                <li>
                    <h3>¿Qué es una API?</h3>
                    <p>Una API (Application Programming Interface) es un conjunto de reglas y protocolos que permite a diferentes aplicaciones comunicarse entre sí.O, si se prefiere, un conjunto de métodos y datos que se pueden utilizar para realizar una tarea o realizar una acción. En Python, una API es un objeto. Veamos una explicación paso a paso:</p>
                    <ul>
                        <li>Una API define cómo las aplicaciones pueden solicitar y enviar datos entre sí.</li>
                        <li>Imagina que tienes una aplicación de clima y quieres mostrar la temperatura actual en tu página web. En lugar de escribir todo el código para obtener los datos del clima tú mismo, puedes utilizar una API de clima existente.</li>
                        <li>La API de clima proporciona una serie de reglas y protocolos que te permiten solicitar datos de temperatura a través de una URL específica.</li>
                        <li>Tu aplicación web puede enviar una solicitud a la API de clima, especificando la ubicación para la que deseas obtener la temperatura.</li>
                        <li>La API de clima procesa tu solicitud y devuelve los datos de temperatura en un formato específico, como JSON o XML.</li>
                        <li>Tu aplicación web puede recibir los datos de temperatura de la API y mostrarlos en tu página web.</li>
                        <li>Además de obtener datos, las API también pueden permitir enviar datos a otras aplicaciones. Por ejemplo, una API de pago puede permitir a tu aplicación enviar una solicitud de pago a un proveedor de servicios de pago.</li>
                        <li>Las API pueden ser públicas, lo que significa que están disponibles para cualquier persona, o privadas, lo que significa que solo están disponibles para ciertos usuarios o aplicaciones autorizadas.</li>
                        <li>Las API son esenciales para la integración de aplicaciones y permiten a los desarrolladores aprovechar la funcionalidad existente en lugar de tener que crearla desde cero.</li>
                    </ul>
                    <p>Algunos ejemplos de API ampliamente conocidas y utilizadas en diferentes áreas:</p>
                    <ul>
                        <li>API de <b>Google Maps</b>: Permite a los desarrolladores integrar mapas interactivos en sus aplicaciones y acceder a funciones como geolocalización, rutas y lugares de interés.</li>
                        <li>API de <b>Twitter</b>: Da acceso a datos y funcionalidades de Twitter, como publicar tweets, leer el timeline de un usuario y buscar tweets por palabras clave.</li>
                        <li>API de <b>Facebook</b>: Proporciona acceso a la plataforma de Facebook, lo que permite a los desarrolladores integrar funciones de inicio de sesión con Facebook, compartir contenido en Facebook y acceder a datos de perfil de usuario.</li>
                        <li>API de <b>PayPal</b>: Posibilita integrar pagos en línea en las aplicaciones, lo que implica aceptar pagos con tarjeta de crédito, transferencias bancarias y otros métodos de pago.</li>
                        <li>API de <b>OpenWeatherMap</b>: Proporciona datos de pronóstico del tiempo y condiciones meteorológicas actuales para cualquier ubicación del mundo.</li>
                        <li>API de <b>YouTube</b>: Otorga acceso a contenido de YouTube, como videos, listas de reproducción y comentarios, y también permite la carga y administración de videos.</li>
                        <li>API de <b>Spotify</b>: Facilita acceder a la biblioteca de música de Spotify, buscar canciones, crear listas de reproducción y reproducir música en sus aplicaciones.</li>
                    </ul>
                    <p>Estos son solo algunos ejemplos, pero hay muchas otras API populares y ampliamente utilizadas en diferentes industrias y áreas de desarrollo de software.</p>
                    <p>En resumen, una API es como un intermediario que permite que diferentes aplicaciones se comuniquen y compartan datos de manera estructurada y eficiente.</p>
                </li>
                <li>
                    <h3>¿Qué es Postman?</h3>
                    <p>Postman es una herramienta de desarrollo de API que permite a los desarrolladores probar, documentar y colaborar en el desarrollo de APIs. Algunas de sus características más importantes son:</p>
                    <ul>
                        <li><b>Interfaz de usuario intuitiva:</b> Postman proporciona una interfaz gráfica fácil de usar que permite a los desarrolladores enviar solicitudes HTTP a una API y ver las respuestas.</li>
                        <li><b>Pruebas automatizadas:</b> Postman permite a los desarrolladores escribir y ejecutar pruebas automatizadas para verificar el comportamiento de una API. Esto es útil para asegurarse de que una API funcione correctamente y cumpla con los requisitos.</li>
                        <li><b>Colecciones y entornos:</b> Postman permite a los desarrolladores organizar sus solicitudes en colecciones, lo que facilita la gestión y la reutilización de las solicitudes. Además, los entornos permiten configurar variables y configuraciones específicas para diferentes entornos, como desarrollo, pruebas o producción.</li>
                        <li><b>Documentación de API:</b> Postman permite generar automáticamente documentación de API a partir de las solicitudes y respuestas guardadas en una colección. Esto facilita la comprensión y el uso de una API por parte de otros desarrolladores.</li>
                        <li><b>Colaboración:</b> Postman permite a los equipos de desarrollo colaborar en el desarrollo de APIs. Los desarrolladores pueden compartir colecciones, colaborar en pruebas y documentación, y trabajar juntos en el desarrollo de APIs.</li>
                    </ul>
                    <p>Un ejemplo de uso de Postman sería probar una API de clima. Podrías enviar una solicitud GET a la URL de la API con los parámetros necesarios, como la ubicación o la fecha, y Postman mostraría la respuesta de la API, que podría incluir información sobre el clima actual en esa ubicación.</p>
                    <p>En resumen, Postman es una herramienta esencial para los desarrolladores de API, ya que les permite probar, documentar y colaborar en el desarrollo de APIs de manera eficiente y efectiva.</p>
                </li>
                <li>
                    <h3>¿Qué es el polimorfismo?</h3>
                    <p>El polimorfismo en Python es un concepto de programación orientada a objetos que permite que un objeto pueda tomar diferentes formas o comportamientos según el contexto en el que se utilice. En otras palabras, un objeto puede ser tratado como si fuera de un tipo diferente al que realmente es.</p>
                    <p>En Python, el polimorfismo se logra mediante el uso de herencia y la implementación de métodos con el mismo nombre en diferentes clases.</p>
                    <p>Cuando se llama a un método en un objeto, Python busca primero en la clase del objeto y luego en las clases superiores en la jerarquía de herencia para encontrar la implementación del método.</p>
                    <p>Si una clase hereda de otra y redefine un método con el mismo nombre, se dice que está sobrescribiendo el método de la clase base.</p>
                    <p>El polimorfismo permite que un objeto de una clase derivada se utilice donde se espera un objeto de la clase base, lo que facilita la reutilización del código y la flexibilidad en el diseño de programas.</p>
                    <pre><code>class Figura:
    def area(self):
        pass

class Rectangulo(Figura):
    def __init__(self, base, altura):
        self.base = base
        self.altura = altura

    def area(self):
        return self.base * self.altura

class Circulo(Figura):
    def __init__(self, radio):
        self.radio = radio

    def area(self):
        return 3.14159 * self.radio ** 2

def calcular_area(figura):
    print("El área de la figura es:", figura.area())

rectangulo = Rectangulo(5, 3)
circulo = Circulo(2)

calcular_area(rectangulo)  # Imprime "El área de la figura es: 15"
calcular_area(circulo)  # Imprime "El área de la figura es: 12.56636"
</code></pre>
                    <p>En este ejemplo, tenemos una clase base llamada <code>Figura</code> que define un método <code>area()</code>. Luego, tenemos dos clases derivadas, <code>Rectangulo</code> y <code>Circulo</code>, que sobrescriben el método <code>area()</code> para calcular el área específica de cada figura. La función <code>calcular_area()</code> toma un objeto de la clase <code>Figura</code> como argumento y llama al método <code>area()</code> en ese objeto para calcular y mostrar el área de la figura. A pesar de que <code>rectangulo</code> y <code>circulo</code> son objetos de clases derivadas, se pueden pasar como argumentos a <code>calcular_area()</code> porque heredan de la clase <code>Figura</code>. Esto demuestra el polimorfismo en acción, ya que el mismo método <code>calcular_area()</code> puede ser utilizado con diferentes tipos de objetos.</p>
                    <p>Un ejemplo común de polimorfismo en Python es el uso de la función <code>len()</code>. Esta función puede ser utilizada para obtener la longitud de una lista, una cadena de texto o cualquier otro objeto que implemente el método <code>__len__</code>.</p>
                    <pre><code>class MiColeccion:
    def __init__(self, elementos):
        self.elementos = elementos

    def __len__(self):
        return len(self.elementos)

mi_lista = [1, 2, 3, 4, 5]
mi_cadena = "Hola, mundo!"
mi_coleccion = MiColeccion([1, 2, 3, 4, 5])

print(len(mi_lista))  # Imprime 5
print(len(mi_cadena))  # Imprime 12
print(len(mi_coleccion))  # Imprime 5
</code></pre>
                    <p>En este ejemplo, se crea una clase <code>MiColeccion</code> que tiene una lista de elementos. La clase implementa el método especial <code>__len__()</code> que devuelve la longitud de la lista de elementos. Luego, utilizamos la función <code>len()</code> para obtener la longitud de una lista, una cadena de texto y una instancia de la clase <code>MiColeccion</code>. A pesar de que los objetos son de tipos diferentes, el polimorfismo nos permite utilizar la misma función <code>len()</code> para obtener la longitud de cada uno de ellos.</p>
                    <p>Veamos un ejemplo más para ilustrar el polimorfismo en Python:</p>
                    <pre><code>class Animal:
    def hablar(self):
        pass

class Perro(Animal):
    def hablar(self):
        return "¡Guau!"

class Gato(Animal):
    def hablar(self):
        return "¡Miau!"

def hacer_hablar(animal):
    print(animal.hablar())

perro = Perro()
gato = Gato()

hacer_hablar(perro)  # Imprime "¡Guau!"
hacer_hablar(gato)  # Imprime "¡Miau!"
</code></pre>
                    <p>En este ejemplo, la función <code>hacer_hablar()</code> puede recibir tanto un objeto de la clase <code>Perro</code> como un objeto de la clase <code>Gato</code>, ya que ambas clases heredan de la clase <code>Animal</code> y tienen un método <code>hablar()</code> definido. Esto demuestra el polimorfismo en acción, ya que el mismo método <code>hacer_hablar()</code> puede ser utilizado con diferentes tipos de objetos.</p>
                </li>
                <li>
                    <h3>¿Qué es un método <i>dunder</i>?</h3>
                    <p><b><i>Dunder</i></b> es una abreviatura de <i>double underscore</i> (doble guion bajo) y se utiliza para referirse a los métodos especiales en Python que comienzan y terminan con dos guiones bajos.</p>
                    <p>Recordar que un método es una función que está asociada a una clase y puede ser llamada en otras partes (instancias) de esa clase.</p>
                    <p>Los métodos <i>dunder</i> son métodos especiales predefinidos en Python que tienen un significado especial y se utilizan para realizar operaciones específicas en objetos.</p>
                    <p>Ejemplos de métodos <i>dunder</i> en Python, son:</p>
                    <ol>
                        <li><b><code>__init__</code></b>: utilizado para inicializar una instancia de una clase. Por ejemplo:
                            <pre><code>class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

persona = Persona("Juan", 25)
</code></pre>
                            <p>El ejemplo muestra cómo se puede definir una clase <code>Persona</code> con un constructor <code>__init__</code> que permite crear instancias de <code>Persona</code> con un nombre y una edad específicos. La instancia <code>persona</code> se crea utilizando el constructor y se inicializa con los valores proporcionados.</p>
                        </li>
                        <li><b><code>__str__</code></b>: utilizado para representar una instancia de una clase como una cadena legible. Por ejemplo:
                            <pre><code>class Persona:
    def __init__(self, nombre, edad):
        self.nombre = nombre
        self.edad = edad

    def __str__(self):
        return f"Persona(nombre={self.nombre}, edad={self.edad})"

persona = Persona("Juan", 25)
print(persona)  # Salida: Persona(nombre=Juan, edad=25)
</code></pre>
                            <p>En el ejemplo vemos como se puede personalizar la representación de una instancia de la clase <code>Persona</code> utilizando el método especial <code>__str__</code>. Esto permite que la instancia de <code>Persona</code> se muestre de una manera más legible y personalizada cuando se utiliza la función <code>print()</code>.</p>
                        </li>
                        <li><b><code>__len__</code></b>: utilizado para obtener la longitud de una instancia de una clase. Por ejemplo:
                            <pre><code>class ListaPersonalizada:
    def __init__(self, elementos):
        self.elementos = elementos

    def __len__(self):
        return len(self.elementos)

lista = ListaPersonalizada([1, 2, 3, 4, 5])
print(len(lista))  # Salida: 5
</code></pre>
                            <p>Aquí vemos cómo se puede personalizar la operación de obtener la longitud de una instancia de la clase <code>ListaPersonalizada</code> utilizando el método especial <code>__len__</code>. Esto permite que la instancia de <code>ListaPersonalizada</code> se comporte como una lista estándar para obtener su longitud utilizando la función <code>len()</code>.</p>
                        </li>
                        <li><b><code>__add__</code></b>: utilizado para definir la operación de suma entre dos instancias de una clase. Por ejemplo:
                            <pre><code>class Punto:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __add__(self, otro_punto):
        nuevo_x = self.x + otro_punto.x
        nuevo_y = self.y + otro_punto.y
        return Punto(nuevo_x, nuevo_y)

punto1 = Punto(1, 2)
punto2 = Punto(3, 4)
resultado = punto1 + punto2
print(resultado.x, resultado.y)  # Salida: 4 6
</code></pre>
                            <p>Este ejemplo muestra cómo se puede personalizar la operación de suma entre dos instancias de la clase <code>Punto</code> utilizando el método especial <code>__add__</code>. Esto permite realizar operaciones matemáticas personalizadas en objetos de la clase <code>Punto</code>.</p>
                        </li>
                        <li><b><code>__getitem__</code></b>: utilizado para acceder a elementos de una instancia de una clase mediante indexación. Por ejemplo:
                            <pre><code>class ListaPersonalizada:
    def __init__(self, elementos):
        self.elementos = elementos

    def __getitem__(self, indice):
        return self.elementos[indice]

lista = ListaPersonalizada([1, 2, 3, 4, 5])
print(lista[2])  # Salida: 3
</code></pre>
                            <p>En este ejemplo, la clase <code>ListaPersonalizada</code> tiene una lista de elementos y el método <code>__getitem__</code> permite acceder a esos elementos utilizando la sintaxis de indexación <code>lista[indice]</code>. Cuando se llama a <code>lista[2]</code>, el método <code>__getitem__</code> se ejecuta y devuelve el elemento en el índice 2 de la lista, que en este caso es el número 3.</p>
                            <p>Es importante destacar que el método <code>__getitem__</code> también puede ser utilizado para implementar otras formas de acceso a elementos, como el acceso mediante <i>slices</i> (rebanadas) o incluso mediante claves en caso de estructuras de datos más complejas.</p>
                        </li>
                    </ol>
                    <p>Los métodos <i>dunder</i> son llamados (invocados) automáticamente en ciertas situaciones, como al crear una instancia de una clase, al imprimir una instancia de una clase o al realizar operaciones específicas en una instancia de una clase.</p>
                    <p>Mencionar que son una parte importante de la programación orientada a objetos en Python y permiten personalizar el comportamiento de las clases y sus instancias.</p>
                    <p>Concluir resaltando que los métodos dunder son una característica poderosa de Python que permite una mayor flexibilidad y personalización en el diseño de clases y objetos.</p>
                </li>
                <li>
                    <h3>¿Qué es un decorador de python?</h3>
                    <ul>
                        <li>Un decorador en Python es una función que toma otra función como argumento y devuelve una nueva función.</li>
                        <li>Los decoradores se utilizan para extender o modificar el comportamiento de una función sin modificar su código fuente original.</li>
                        <li>Los decoradores se aplican utilizando la sintaxis del signo @ antes de la definición de una función.</li>
                        <li>Los decoradores pueden realizar acciones como registrar información, medir el tiempo de ejecución, validar entradas o salidas, agregar caché, entre otros.</li>
                        <li>Los decoradores son útiles para aplicar lógica común a varias funciones sin tener que repetir el código en cada una de ellas.</li>
                        <li>Los decoradores pueden ser anidados, lo que significa que se pueden aplicar varios decoradores a una función.</li>
                        <li>Los decoradores también se pueden aplicar a métodos de clase y métodos estáticos en Python.</li>
                        <li>Los decoradores son una característica poderosa y flexible de Python que permite la reutilización de código y la adición de funcionalidad de manera modular.</li>
                    </ul>
                    <p>Ejemplo de decorador para validar argumentos de una función:</p>
                    <pre><code>def validate_arguments_decorator(func):
    def wrapper(*args, **kwargs):
        for arg in args:
            if not isinstance(arg, int):
                raise ValueError("Los argumentos deben ser enteros.")
        return func(*args, **kwargs)
    return wrapper

@validate_arguments_decorator
def add_numbers(a, b):
    return a + b

result = add_numbers(5, 10)
print(result)
</code></pre>
                    <p>Ejemplo de decorador para medir el tiempo de ejecución de una función:</p>
                    <pre><code>import time

def timer_decorator(func):
    def wrapper(*args, **kwargs):
        start_time = time.time()
        result = func(*args, **kwargs)
        end_time = time.time()
        execution_time = end_time - start_time
        print(f"La función {func.__name__} tardó {execution_time} segundos en ejecutarse.")
        return result
    return wrapper

@timer_decorator
def my_function():
    # Código de la función
    pass

my_function()
</code></pre>
                    <p>Ejemplo de decorador para agregar caché a una función:</p>
                    <pre><code>def cache_decorator(func):
    cache = {}

    def wrapper(*args):
        if args in cache:
            return cache[args]
        result = func(*args)
        cache[args] = result
        return result

    return wrapper

@cache_decorator
def fibonacci(n):
    if n &lt;= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

result = fibonacci(10)
print(result)
</code></pre>
                    <p>Estos son solo algunos ejemplos básicos de decoradores en Python. Los decoradores pueden ser utilizados de muchas formas diferentes y se pueden adaptar para cumplir con requisitos específicos en diferentes situaciones.</p>
                    <p>Es importante tener en cuenta que los decoradores pueden ser un concepto un poco avanzado para los principiantes en Python, por lo que es recomendable tener un buen entendimiento de las funciones y la sintaxis de Python antes de utilizarlos.</p>


                    <h4>Un decorador en Python es una función que toma otra función como argumento y extiende o modifica su comportamiento sin modificar el código fuente original de la función. Los decoradores son una forma elegante de agregar funcionalidad a una función existente sin cambiar su implementación.</h4>

                    <p>Los decoradores se denotan mediante el símbolo @ seguido del nombre de la función decoradora, que se coloca directamente encima de la definición de la función o clase. Cuando se llama a la función o clase decorada, la función decoradora se ejecuta en primer lugar, lo que permite añadir funcionalidad adicional o modificar el comportamiento de la función o clase original.</p>

                    <p>Los decoradores se utilizan habitualmente para tareas como:</p>
                    <ul>
                        <li>Añadir funcionalidad adicional a una función o clase, como registro, temporización o validación de entrada.</li>
                        <li>Modificar el comportamiento de una función o clase, como la memorización o el almacenamiento en caché.</li>
                        <li>Implementar problemas transversales, como la autenticación o la autorización.</li>
                    </ul>
                    <p>Aquí hay algunos puntos clave para entender acerca de los decoradores:</p>
                    <ul>
                        <li>Los decoradores son funciones que toman una función o clase como entrada y devuelven una versión modificada de esa función o clase.</li>
                        <li>Los decoradores se aplican utilizando el símbolo @ seguido del nombre de la función decoradora.</li>
                        <li>Los decoradores pueden utilizarse para modificar el comportamiento de funciones o clases sin modificar directamente su código fuente.</li>
                        <li>Los decoradores pueden apilarse, lo que significa que pueden aplicarse varios decoradores a una misma función o clase.</li>
                        <li>Los decoradores pueden definirse como funciones normales o como clases que implementan el método __call__.</li>
                    </ul>

                </li>
            </ul>
        </li>
        <li>
            <p>y después tienes que realizar este ejercicio y mandarmelo:</p>
            <ul>
                <li>
                    <p>Create a Python class called User that uses the init method and creates a username and a password. Create an object using the class.</p>
                    <pre><code>class User:
    def __init__(self, username, password):
        self.username = username
        self.password = password

# Creating an object using the class
usuario = User("Pepito Palotes", "Password-369")</code></pre>
                </li>
            </ul>
        </li>
    </ul>

</body>

</html>